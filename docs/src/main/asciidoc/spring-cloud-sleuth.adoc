:github-tag: master
:github-repo: spring-cloud/spring-cloud-sleuth
:github-raw: https://raw.githubusercontent.com/{github-repo}/{github-tag}
:github-code: https://github.com/{github-repo}/tree/{github-tag}
:toc: left
:toclevels: 8
:nofooter:
:sectlinks: true

Spring Cloud Sleuth
====================
Adrian Cole, Spencer Gibb, Marcin Grzejszczak, Dave Syer

*{spring-cloud-version}*

:doctype: book

include::intro.adoc[]

include::features.adoc[]

=== Introduction to Brave

IMPORTANT: Starting with version `2.0.0` Spring Cloud Sleuth uses
https://github.com/openzipkin/brave[Brave] as the tracing library.
For your convenience we're embedding part of the Brave's docs here.

Brave is a library used to capture and report latency information about
distributed operations to Zipkin. Most users won't use Brave directly,
rather libraries or frameworks than employ Brave on their behalf.

This module includes tracer creates and joins spans that model the
latency of potentially distributed work. It also includes libraries to
propagate the trace context over network boundaries, for example, via
http headers.

==== Tracing

Most importantly, you need a `brave.Tracer`, configured to [report to Zipkin]
(https://github.com/openzipkin/zipkin-reporter-java).

Here's an example setup that sends trace data (spans) to Zipkin over
http (as opposed to Kafka).

```java

class MyClass {

    private final Tracer tracer;

    // Tracer will be autowired
    MyClass(Tracer tracer) {
        this.tracer = tracer;
    }

    void doSth() {
        Span span = tracer.newTrace().name("encode").start();
        // ...
    }
}
```

IMPORTANT: If your span contains a name greater than 50 chars, then that name will
be truncated to 50 chars. Your names have to be explicit and concrete. Big names lead to
latency issues and sometimes even thrown exceptions.

==== Tracing

The tracer creates and joins spans that model the latency of potentially
distributed work. It can employ sampling to reduce overhead in process
or to reduce the amount of data sent to Zipkin.

Spans returned by a tracer report data to Zipkin when finished, or do
nothing if unsampled. After starting a span, you can annotate events of
interest or add tags containing details or lookup keys.

Spans have a context which includes trace identifiers that place it at
the correct spot in the tree representing the distributed operation.

==== Local Tracing

When tracing local code, just run it inside a span.

```java
Span span = tracer.newTrace().name("encode").start();
try {
  doSomethingExpensive();
} finally {
  span.finish();
}
```

In the above example, the span is the root of the trace. In many cases,
you will be a part of an existing trace. When this is the case, call
`newChild` instead of `newTrace`

```java
Span span = tracer.newChild(root.context()).name("encode").start();
try {
  doSomethingExpensive();
} finally {
  span.finish();
}
```

==== Customizing spans

Once you have a span, you can add tags to it, which can be used as lookup
keys or details. For example, you might add a tag with your runtime
version.

```java
span.tag("clnt/finagle.version", "6.36.0");
```

When exposing the ability to customize spans to third parties, prefer
`brave.SpanCustomizer` as opposed to `brave.Span`. The former is simpler to
understand and test, and doesn't tempt users with span lifecycle hooks.

```java
interface MyTraceCallback {
  void request(Request request, SpanCustomizer customizer);
}
```

Since `brave.Span` implements `brave.SpanCustomizer`, it is just as easy for you
to pass to users.

Ex.
```java
for (MyTraceCallback callback : userCallbacks) {
  callback.request(request, span);
}
```

==== Implicitly looking up the current span

Sometimes you won't know if a trace is in progress or not, and you don't
want users to do null checks. `brave.CurrentSpanCustomizer` adds to any
span that's in progress or drops data accordingly.

Ex.
```java
// user code can then inject this without a chance of it being null.
@Autowire SpanCustomizer span;

void userCode() {
  span.annotate("tx.started");
  ...
}
```

==== RPC tracing

Check for https://github.com/openzipkin/sleuth/tree/master/instrumentation[instrumentation written here]
and http://zipkin.io/pages/existing_instrumentations.html[Zipkin's list]
before rolling your own RPC instrumentation!

RPC tracing is often done automatically by interceptors. Under the scenes,
they add tags and events that relate to their role in an RPC operation.

Here's an example of a client span:

```java
// before you send a request, add metadata that describes the operation
span = tracer.newTrace().name("get").type(CLIENT);
span.tag("clnt/finagle.version", "6.36.0");
span.tag(TraceKeys.HTTP_PATH, "/api");
span.remoteEndpoint(Endpoint.builder()
    .serviceName("backend")
    .ipv4(127 << 24 | 1)
    .port(8080).build());

// when the request is scheduled, start the span
span.start();

// if you have callbacks for when data is on the wire, note those events
span.annotate(Constants.WIRE_SEND);
span.annotate(Constants.WIRE_RECV);

// when the response is complete, finish the span
span.finish();
```

===== One-Way tracing

Sometimes you need to model an asynchronous operation, where there is a
request, but no response. In normal RPC tracing, you use `span.finish()`
which indicates the response was received. In one-way tracing, you use
`span.flush()` instead, as you don't expect a response.

Here's how a client might model a one-way operation
```java
// start a new span representing a client request
oneWaySend = tracer.newSpan(parent).kind(Span.Kind.CLIENT);

// Add the trace context to the request, so it can be propagated in-band
tracing.propagation().injector(Request::addHeader)
                     .inject(oneWaySend.context(), request);

// fire off the request asynchronously, totally dropping any response
request.execute();

// start the client side and flush instead of finish
oneWaySend.start().flush();
```

And here's how a server might handle this..
```java
// pull the context out of the incoming request
extractor = tracing.propagation().extractor(Request::getHeader);

// convert that context to a span which you can name and add tags to
oneWayReceive = nextSpan(tracer, extractor.extract(request))
    .name("process-request")
    .kind(SERVER)
    ... add tags etc.

// start the server side and flush instead of finish
oneWayReceive.start().flush();

// you should not modify this span anymore as it is complete. However,
// you can create children to represent follow-up work.
next = tracer.newSpan(oneWayReceive.context()).name("step2").start();
```

**Note** The above propagation logic is a simplified version of our [http handlers](https://github.com/openzipkin/sleuth/tree/master/instrumentation/http#http-server).

There's a working example of a one-way span [here](src/test/java/sleuth/features/async/OneWaySpanTest.java).

== Sampling

Sampling may be employed to reduce the data collected and reported out
of process. When a span isn't sampled, it adds no overhead (noop).

Sampling is an up-front decision, meaning that the decision to report
data is made at the first operation in a trace, and that decision is
propagated downstream.

By default, there's a global sampler that applies a single rate to all
traced operations. `Tracer.Builder.sampler` is how you indicate this,
and it defaults to trace every request.

=== Declarative sampling

Some need to sample based on the type or annotations of a java method.

Most users will use a framework interceptor which automates this sort of
policy. Here's how they might work internally.

```java
// derives a sample rate from an annotation on a java method
DeclarativeSampler<Traced> sampler = DeclarativeSampler.create(Traced::sampleRate);

@Around("@annotation(traced)")
public Object traceThing(ProceedingJoinPoint pjp, Traced traced) throws Throwable {
  Span span = tracing.tracer().newTrace(sampler.sample(traced))...
  try {
    return pjp.proceed();
  } finally {
    span.finish();
  }
}
```

=== Custom sampling

You may want to apply different policies depending on what the operation
is. For example, you might not want to trace requests to static resources
such as images, or you might want to trace all requests to a new api.

Most users will use a framework interceptor which automates this sort of
policy. Here's how they might work internally.

```java
Span newTrace(Request input) {
  SamplingFlags flags = SamplingFlags.NONE;
  if (input.url().startsWith("/experimental")) {
    flags = SamplingFlags.SAMPLED;
  } else if (input.url().startsWith("/static")) {
    flags = SamplingFlags.NOT_SAMPLED;
  }
  return tracer.newTrace(flags);
}
```

Note: the above is the basis for the built-in https://github.com/openzipkin/sleuth/tree/master/instrumentation/http[http sampler]

=== Sampling in Spring Cloud Sleuth

Spring Cloud Sleuth by default sets all spans to non-exportable.
That means that you will see traces in logs, but not in any remote store.
For testing the default is often enough, and it probably is all you need
if you are only using the logs (e.g. with an ELK aggregator). If you are
exporting span data to Zipkin, there is also an `Sampler.ALWAYS_SAMPLE`
that exports everything and a `ProbabilityBasedSampler` that samples a
fixed fraction of spans.

NOTE: The `ProbabilityBasedSampler` is the default if you are using
`spring-cloud-sleuth-zipkin`. You can
configure the exports using `spring.sleuth.sampler.probability`. The passed
value needs to be a double from `0.0` to `1.0`.

A sampler can be installed just by creating a bean definition, e.g:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=always_sampler,indent=0]
----

TIP: You can set the HTTP header `X-B3-Flags` to `1` or when doing messaging you can
set `spanFlags` header to `1`. Then the current span will be forced to be exportable
regardless of the sampling decision.

== Propagation

Propagation is needed to ensure activity originating from the same root
are collected together in the same trace. The most common propagation
approach is to copy a trace context from a client sending an RPC request
to a server receiving it.

For example, when an downstream Http call is made, its trace context is
sent along with it, encoded as request headers:

```
   Client Span                                                Server Span
┌──────────────────┐                                       ┌──────────────────┐
│                  │                                       │                  │
│   TraceContext   │           Http Request Headers        │   TraceContext   │
│ ┌──────────────┐ │          ┌───────────────────┐        │ ┌──────────────┐ │
│ │ TraceId      │ │          │ X─B3─TraceId      │        │ │ TraceId      │ │
│ │              │ │          │                   │        │ │              │ │
│ │ ParentSpanId │ │ Extract  │ X─B3─ParentSpanId │ Inject │ │ ParentSpanId │ │
│ │              ├─┼─────────>│                   ├────────┼>│              │ │
│ │ SpanId       │ │          │ X─B3─SpanId       │        │ │ SpanId       │ │
│ │              │ │          │                   │        │ │              │ │
│ │ Sampled      │ │          │ X─B3─Sampled      │        │ │ Sampled      │ │
│ └──────────────┘ │          └───────────────────┘        │ └──────────────┘ │
│                  │                                       │                  │
└──────────────────┘                                       └──────────────────┘
```

The names above are from https://github.com/openzipkin/b3-propagation[B3 Propagation],
which is built-in to Brave and has implementations in many languages and
frameworks.

Most users will use a framework interceptor which automates propagation.
Here's how they might work internally.

Here's what client-side propagation might look like

```java
// configure a function that injects a trace context into a request
injector = tracing.propagation().injector(Request.Builder::addHeader);

// before a request is sent, add the current span's context to it
injector.inject(span.context(), request);
```

Here's what server-side propagation might look like

```java
// configure a function that extracts the trace context from a request
extracted = tracing.propagation().extractor(Request::getHeader);

// when a server receives a request, it joins or starts a new trace
span = tracer.nextSpan(extracted, request);
```

=== Propagating extra fields

Sometimes you need to propagate extra fields, such as a request ID or an alternate trace context.
For example, if you are in a Cloud Foundry environment, you might want to pass the request ID:

```java
// when you initialize the builder, define the extra field you want to propagate
tracingBuilder.propagationFactory(
  ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, "x-vcap-request-id")
);

// later, you can tag that request ID or use it in log correlation
requestId = ExtraFieldPropagation.get("x-vcap-request-id");
```

You may also need to propagate a trace context you aren't using. For example, you may be in an
Amazon Web Services environment, but not reporting data to X-Ray. To ensure X-Ray can co-exist
correctly, pass-through its tracing header like so.

```java
tracingBuilder.propagationFactory(
  ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, "x-amzn-trace-id")
);
```

==== Prefixed fields

You can also prefix fields, if they follow a common pattern. For example, the following will
propagate the field "x-vcap-request-id" as-is, but send the fields "country-code" and "user-id"
on the wire as "x-baggage-country-code" and "x-baggage-user-id" respectively.

Setup your tracing instance with allowed fields:

```java
tracingBuilder.propagationFactory(
  ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)
                       .addField("x-vcap-request-id")
                       .addPrefixedFields("baggage-", Arrays.asList("country-code", "user-id"))
                       .build()
);
```

Later, you can call below to affect the country code of the current trace context

```java
ExtraFieldPropagation.set("country-code", "FO");
String countryCode = ExtraFieldPropagation.get("country-code");
```

Or, if you have a reference to a trace context, use it explicitly

```java
ExtraFieldPropagation.set(span.context(), "country-code", "FO");
String countryCode = ExtraFieldPropagation.get(span.context(), "country-code");
```

IMPORTANT: In comparison to previous versions of Sleuth, with
Brave it's required to pass the list of baggage keys.
There are two properties to achieve this. Via the `spring.sleuth.baggage-keys` you set keys
that will get prefixed with `baggage-` for http calls and `baggage_` for messaging. You can also pass
a list of prefixed keys that will be whitelisted without any prefix via
`spring.sleuth.prefixed-keys` property.

==== Extracting a propagated context

The `TraceContext.Extractor<C>` reads trace identifiers and sampling status
from an incoming request or message. The carrier is usually a request object
or headers.

This utility is used in standard instrumentation like [HttpServerHandler](../instrumentation/http/src/main/java/sleuth/http/HttpServerHandler.java),
but can also be used for custom RPC or messaging code.

`TraceContextOrSamplingFlags` is usually only used with `Tracer.nextSpan(extracted)`, unless you are
sharing span IDs between a client and a server.

==== Sharing span IDs between client and server

A normal instrumentation pattern is creating a span representing the server
side of an RPC. `Extractor.extract` might return a complete trace context when
applied to an incoming client request. `Tracer.joinSpan` attempts to continue
the this trace, using the same span ID if supported, or creating a child span
if not. When span ID is shared, data reported includes a flag saying so.

Here's an example of B3 propagation:

```
                              ┌───────────────────┐      ┌───────────────────┐
 Incoming Headers             │   TraceContext    │      │   TraceContext    │
┌───────────────────┐(extract)│ ┌───────────────┐ │(join)│ ┌───────────────┐ │
│ X─B3-TraceId      │─────────┼─┼> TraceId      │ │──────┼─┼> TraceId      │ │
│                   │         │ │               │ │      │ │               │ │
│ X─B3-ParentSpanId │─────────┼─┼> ParentSpanId │ │──────┼─┼> ParentSpanId │ │
│                   │         │ │               │ │      │ │               │ │
│ X─B3-SpanId       │─────────┼─┼> SpanId       │ │──────┼─┼> SpanId       │ │
└───────────────────┘         │ │               │ │      │ │               │ │
                              │ │               │ │      │ │  Shared: true │ │
                              │ └───────────────┘ │      │ └───────────────┘ │
                              └───────────────────┘      └───────────────────┘
```

Some propagation systems only forward the parent span ID, detected when
`Propagation.Factory.supportsJoin() == false`. In this case, a new span ID is
always provisioned and the incoming context determines the parent ID.

Here's an example of AWS propagation:
```
                              ┌───────────────────┐      ┌───────────────────┐
 x-amzn-trace-id              │   TraceContext    │      │   TraceContext    │
┌───────────────────┐(extract)│ ┌───────────────┐ │(join)│ ┌───────────────┐ │
│ Root              │─────────┼─┼> TraceId      │ │──────┼─┼> TraceId      │ │
│                   │         │ │               │ │      │ │               │ │
│ Parent            │─────────┼─┼> SpanId       │ │──────┼─┼> ParentSpanId │ │
└───────────────────┘         │ └───────────────┘ │      │ │               │ │
                              └───────────────────┘      │ │  SpanId: New  │ │
                                                         │ └───────────────┘ │
                                                         └───────────────────┘
```

Note: Some span reporters do not support sharing span IDs. For example, if you
set `Tracing.Builder.spanReporter(amazonXrayOrGoogleStackdrive)`, disable join
via `Tracing.Builder.supportsJoin(false)`. This will force a new child span on
`Tracer.joinSpan()`.

==== Implementing Propagation

`TraceContext.Extractor<C>` is implemented by a `Propagation.Factory` plugin. Internally, this code
will create the union type `TraceContextOrSamplingFlags` with one of the following:
* `TraceContext` if trace and span IDs were present.
* `TraceIdContext` if a trace ID was present, but not span IDs.
* `SamplingFlags` if no identifiers were present

Some `Propagation` implementations carry extra data from point of extraction (ex reading incoming
headers) to injection (ex writing outgoing headers). For example, it might carry a request ID. When
implementations have extra data, here's how they handle it.
* If a `TraceContext` was extracted, add the extra data as `TraceContext.extra()`
* Otherwise, add it as `TraceContextOrSamplingFlags.extra()`, which `Tracer.nextSpan` handles.

== Current Tracing Component

Brave supports a "current tracing component" concept which should only
be used when you have no other means to get a reference. This was made
for JDBC connections, as they often initialize prior to the tracing
component.

The most recent tracing component instantiated is available via
`Tracing.current()`. You there's also a shortcut to get only the tracer
via `Tracing.currentTracer()`. If you use either of these methods, do
noot cache the result. Instead, look them up each time you need them.

== Current Span

Brave supports a "current span" concept which represents the in-flight
operation. `Tracer.currentSpan()` can be used to add custom tags to a
span and `Tracer.nextSpan()` can be used to create a child of whatever
is in-flight.

=== Setting a span in scope manually

When writing new instrumentation, it is important to place a span you
created in scope as the current span. Not only does this allow users to
access it with `Tracer.currentSpan()`, but it also allows customizations
like SLF4J MDC to see the current trace IDs.

`Tracer.withSpanInScope(Span)` facilitates this and is most conveniently
employed via the try-with-resources idiom. Whenever external code might
be invoked (such as proceeding an interceptor or otherwise), place the
span in scope like this.

```java
try (SpanInScope ws = tracer.withSpanInScope(span)) {
  return inboundRequest.invoke();
} finally { // note the scope is independent of the span
  span.finish();
}
```

In edge cases, you may need to clear the current span temporarily. For
example, launching a task that should not be associated with the current
request. To do this, simply pass null to `withSpanInScope`.

```java
try (SpanInScope cleared = tracer.withSpanInScope(null)) {
  startBackgroundThread();
}
```

== Instrumentation

Spring Cloud Sleuth instruments all your Spring application
automatically, so you shouldn't have to do anything to activate
it. The instrumentation is added using a variety of technologies
according to the stack that is available, e.g. for a servlet web
application we use a `Filter`, and for Spring Integration we use
`ChannelInterceptors`.

You can customize the keys used in span tags. To limit the volume of
span data, by default an HTTP request will be tagged only with a
handful of metadata like the status code, host and URL. You can add
request headers by configuring `spring.sleuth.keys.http.headers` (a
list of header names).

NOTE: Remember that tags are only collected and exported if there is a
`Sampler` that allows it (by default there is not, so there is no
danger of accidentally collecting too much data without configuring
something).

== Span lifecycle

You can do the following operations on the Span by means of *brave.Tracer*:

- <<creating-and-finishing-spans, start>> - when you start a span its name is assigned and start timestamp is recorded.
- <<creating-and-finishing-spans, close>> - the span gets finished (the end time of the span is recorded) and if
the span is *sampled* then it will be eligible for collection to e.g. Zipkin.
- <<continuing-spans, continue>> - a new instance of span will be created whereas it will be a copy of the
one that it continues.
- <<continuing-spans, detach>> - the span doesn't get stopped or closed. It only gets removed from the current thread.
- <<creating-spans-with-explicit-parent, create with explicit parent>> - you can create a new span and set an explicit parent to it

TIP: Spring Cloud Sleuth creates the instance of `Tracer` for you. In order to use it,
all you need is to just autowire it.

=== Creating and finishing spans [[creating-and-finishing-spans]]

You can manually create spans by using the *Tracer*.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=manual_span_creation,indent=0]
----

In this example we could see how to create a new instance of span. Assuming that there already
was a span present in this thread then it would become the parent of that span.

IMPORTANT: Always clean after you create a span! Don't forget to finish a span if you want to send it to Zipkin.

IMPORTANT: If your span contains a name greater than 50 chars, then that name will
be truncated to 50 chars. Your names have to be explicit and concrete. Big names lead to
latency issues and sometimes even thrown exceptions.

=== Continuing spans [[continuing-spans]]

Sometimes you don't want to create a new span but you want to continue one. Example of such a
situation might be (of course it all depends on the use-case):

    - *AOP* - If there was already a span created before an aspect was reached then you might not want to create a new span.
    - *Hystrix* - executing a Hystrix command is most likely a logical part of the current processing. It's in fact
    only a technical implementation detail that you wouldn't necessarily want to reflect in tracing as a separate being.

To continue a span you can use *brave.Tracer*.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=manual_span_continuation,indent=0]
----

=== Creating spans with an explicit parent [[creating-spans-with-explicit-parent]]

There is a possibility that you want to start a new span and provide an explicit parent of that span.
Let's assume that the parent of a span is in one thread and you want to start a new span in another thread.
In Brave, whenever you call `nextSpan()`, it's creating one in reference
to the span being currently in scope. It's enough to just put
the span in scope and then call `nextSpan()`, as presented in the example below:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=manual_span_joining,indent=0]
----

IMPORTANT: After having created such a span remember to finish it, otherwise it will not get
reported to e.g. Zipkin

== Naming spans

Picking a span name is not a trivial task. Span name should depict an operation name. The name should
be low cardinality (e.g. not include identifiers).

Since there is a lot of instrumentation going on some of the span names will be
artificial like:

- `controller-method-name` when received by a Controller with a method name `conrollerMethodName`
- `async` for asynchronous operations done via wrapped `Callable` and `Runnable`.
- `@Scheduled` annotated methods will return the simple name of the class.

Fortunately, for the asynchronous processing you can provide explicit naming.

=== @SpanName annotation

You can name the span explicitly via the `@SpanName` annotation.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=span_name_annotation,indent=0]
----

In this case, when processed in the following manner:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=span_name_annotated_runnable_execution,indent=0]
----

The span will be named `calculateTax`.

=== toString() method

It's pretty rare to create separate classes for `Runnable` or `Callable`. Typically one creates an anonymous
instance of those classes. You can't annotate such classes thus to override that, if there is no `@SpanName` annotation present,
we're checking if the class has a custom implementation of the `toString()` method.

So executing such code:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=span_name_to_string_runnable_execution,indent=0]
----

will lead in creating a span named `calculateTax`.

== Managing spans with annotations

=== Rationale

The main arguments for this features are

* api-agnostic means to collaborate with a span
    - use of annotations allows users to add to a span with no library dependency on a span api.
    This allows Sleuth to change its core api less impact to user code.
* reduced surface area for basic span operations.
    - without this feature one has to use the span api, which has lifecycle commands that
    could be used incorrectly. By only exposing scope, tag and log functionality, users can
    collaborate without accidentally breaking span lifecycle.
* collaboration with runtime generated code
    - with libraries such as Spring Data / Feign the implementations of interfaces are generated
    at runtime thus span wrapping of objects was tedious. Now you can provide annotations
     over interfaces and arguments of those interfaces

=== Creating new spans

If you really don't want to take care of creating local spans manually you can profit from the
`@NewSpan` annotation. Also we give you the `@SpanTag` annotation to add tags in an automated
fashion.

Let's look at some examples of usage.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=annotated_method,indent=0]
----

Annotating the method without any parameter will lead to a creation of a new span whose name
will be equal to annotated method name.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=custom_name_on_annotated_method,indent=0]
----

If you provide the value in the annotation (either directly or via the `name` parameter) then
the created span will have the name as the provided value.

[source,java]
----
// method declaration
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=custom_name_and_tag_on_annotated_method,indent=0]

// and method execution
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=execution,indent=0]
----

You can combine both the name and a tag. Let's focus on the latter. In this case whatever the value of
the annotated method's parameter runtime value will be - that will be the value of the tag. In our sample
the tag key will be `testTag` and the tag value will be `test`.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=name_on_implementation,indent=0]
----

You can place the `@NewSpan` annotation on both the class and an interface. If you override the
interface's method and provide a different value of the `@NewSpan` annotation then the most
concrete one wins (in this case `customNameOnTestMethod3` will be set).

=== Continuing spans

If you want to just add tags and annotations to an existing span it's enough
to use the `@ContinueSpan` annotation as presented below. Note that in contrast
with the `@NewSpan` annotation you can also add logs via the `log` parameter:

[source,java]
----
// method declaration
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=continue_span,indent=0]

// method execution
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SleuthSpanCreatorAspectTests.java[tags=continue_span_execution,indent=0]
----

That way the span will get continued and:

 - logs with name `testMethod11.before` and `testMethod11.after` will be created
 - if an exception will be thrown a log `testMethod11.afterFailure` will also be created
 - tag with key `testTag11` and value `test` will be created

=== More advanced tag setting

There are 3 different ways to add tags to a span. All of them are controlled by the `SpanTag` annotation.
Precedence is:

- try with the bean of `TagValueResolver` type and provided name
- if one hasn't provided the bean name, try to evaluate an expression. We're searching for a `TagValueExpressionResolver` bean.
The default implementation uses SPEL expression resolution.
- if one hasn't provided any expression to evaluate just return a `toString()` value of the parameter

==== Custom extractor

The value of the tag for following method will be computed by an implementation of `TagValueResolver` interface.
Its class name has to be passed as the value of the `resolver` attribute.

Having such an annotated method:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SpanTagAnnotationHandlerTests.java[tags=resolver_bean,indent=0]
----

and such a `TagValueResolver` bean implementation

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SpanTagAnnotationHandlerTests.java[tags=custom_resolver,indent=0]
----

Will lead to setting of a tag value equal to `Value from myCustomTagValueResolver`.

==== Resolving expressions for value

Having such an annotated method:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SpanTagAnnotationHandlerTests.java[tags=spel,indent=0]
----

and no custom implementation of a `TagValueExpressionResolver` will lead to evaluation of the SPEL expression and a tag with value `4 characters` will be set on the span.
If you want to use some other expression resolution mechanism you can create your own implementation
of the bean.

==== Using toString method

Having such an annotated method:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/annotation/SpanTagAnnotationHandlerTests.java[tags=toString,indent=0]
----

if executed with a value of `15` will lead to setting of a tag with a String value of `"15"`.

== Customizations

// TODO: Update this

=== Spring Integration


=== HTTP

// TODO: Update this

=== TraceFilter

You can also modify the behaviour of the `TraceFilter` - the component that is responsible
for processing the input HTTP request and adding tags basing on the HTTP response. You can customize
the tags, or modify the response headers by registering your own instance of the `TraceFilter` bean.

In the following example we will register the `TraceFilter` bean and we will add the
`ZIPKIN-TRACE-ID` response header containing the current Span's trace id. Also we will
add to the Span a tag with key `custom` and a value `tag`.

[source,java]
----
include::../../../..//spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/web/TraceFilterIntegrationTests.java[tags=response_headers,indent=0]
----

=== Custom service name

By default Sleuth assumes that when you send a span to Zipkin, you want the span's service name
 to be equal to `spring.application.name` value. That's not always the case though. There
 are situations in which you want to explicitly provide a different service name for all spans coming
 from your application. To achieve that it's enough to just pass the following property
 to your application to override that value (example for `foo` service name):

[source,yaml]
----
spring.zipkin.service.name: foo
----

=== Customization of reported spans

Before reporting spans to e.g. Zipkin you can be interested in modifying that span in some way.
 You can achieve that by using the `SpanAdjuster` interface.

In Sleuth we're generating spans with a fixed name. Some users want to modify the name depending on values
of tags. Implementation of the `SpanAdjuster` interface can be used to alter that name. Example:

Example. If you register two beans of `SpanAdjuster` type:

[source,java]
----
include::../../../..//spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/SpanAdjusterTests.java[tags=adjuster,indent=0]
----

This will lead in changing the name of the reported span to `foo bar`, just before it gets reported (e.g. to Zipkin).

=== Host locator

IMPORTANT: This section is about defining *host* from service discovery. It's *NOT*
about finding Zipkin in service discovery.

In order to define the host that is corresponding to a particular span we need to resolve the host name
and port. The default approach is to take it from server properties. If those for some reason are not set
then we're trying to retrieve the host name from the network interfaces.

If you have the discovery client enabled and prefer to retrieve the host address from the registered
instance in a service registry then you have to set the property (it's applicable for both HTTP and
Stream based span reporting).

[source,yaml]
----
spring.zipkin.locator.discovery.enabled: true
----

== Sending spans to Zipkin

By default if you add `spring-cloud-starter-zipkin` as a dependency to your project,
when the span is closed, it will be sent to Zipkin over HTTP. The communication
is asynchronous. You can configure the URL by setting the `spring.zipkin.baseUrl`
property as follows:

[source,yaml]
----
spring.zipkin.baseUrl: http://192.168.99.100:9411/
----

If you want to find Zipkin via service discovery it's enough to pass the
Zipkin's service id inside the URL (example for `zipkinserver` service id)

[source,yaml]
----
spring.zipkin.baseUrl: http://zipkinserver/
----

== Zipkin Stream Span Consumer

IMPORTANT: The suggested approach is to use the Zipkin's
native support for message based span sending. Starting from
Edgware Zipkin Stream server is deprecated and in Finchley
it got removed.

Please refer to the http://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi__span_data_as_messages.html#_zipkin_consumer[Dalston Documentaion]
on how to create a Stream Zipkin server.

== Integrations

=== OpenTracing

Spring Cloud Sleuth is http://opentracing.io/[OpenTracing] compatible. If you have
OpenTracing on the classpath we will automatically register the OpenTracing
`Tracer` bean. If you wish to disable this just set `spring.sleuth.opentracing.enabled` to `false`

=== Runnable and Callable

If you're wrapping your logic in `Runnable` or `Callable` it's enough to wrap those classes in their Sleuth representative.

Example for `Runnable`:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=trace_runnable,indent=0]
----

Example for `Callable`:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/documentation/SpringCloudSleuthDocTests.java[tags=trace_callable,indent=0]
----

That way you will ensure that a new Span is created and closed for each execution.

=== Hystrix

==== Custom Concurrency Strategy

We're registering a custom https://github.com/Netflix/Hystrix/wiki/Plugins#concurrencystrategy[`HystrixConcurrencyStrategy`]
that wraps all `Callable` instances into their Sleuth representative -
the `TraceCallable`. The strategy either starts or continues a span depending on the fact whether tracing was already going
on before the Hystrix command was called. To disable the custom Hystrix Concurrency Strategy set the `spring.sleuth.hystrix.strategy.enabled` to `false`.

==== Manual Command setting

Assuming that you have the following `HystrixCommand`:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/hystrix/TraceCommandTests.java[tags=hystrix_command,indent=0]
----

In order to pass the tracing information you have to wrap the same logic in the Sleuth version of the `HystrixCommand` which is the
`TraceCommand`:

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/hystrix/TraceCommandTests.java[tags=trace_hystrix_command,indent=0]
----

=== RxJava

We're registering a custom https://github.com/ReactiveX/RxJava/wiki/Plugins#rxjavaschedulershook[`RxJavaSchedulersHook`]
that wraps all `Action0` instances into their Sleuth representative -
the `TraceAction`. The hook either starts or continues a span depending on the fact whether tracing was already going
on before the Action was scheduled. To disable the custom RxJavaSchedulersHook set the `spring.sleuth.rxjava.schedulers.hook.enabled` to `false`.

You can define a list of regular expressions for thread names, for which you don't want a Span to be created. Just provide a comma separated list
of regular expressions in the `spring.sleuth.rxjava.schedulers.ignoredthreads` property.

=== HTTP integration

Features from this section can be disabled by providing the `spring.sleuth.web.enabled` property with value equal to `false`.

==== HTTP Filter

Via the `TraceFilter` all sampled incoming requests result in creation of a Span. That Span's name is `http:` + the path to which
 the request was sent. E.g. if the request was sent to `/foo/bar` then the name will be `http:/foo/bar`. You can configure which URIs you would
 like to skip via the `spring.sleuth.web.skipPattern` property. If you have `ManagementServerProperties` on classpath then
 its value of `contextPath` gets appended to the provided skip pattern.

==== HandlerInterceptor

Since we want the span names to be precise we're using a `TraceHandlerInterceptor` that either wraps an
 existing `HandlerInterceptor` or is added directly to the list of existing `HandlerInterceptors`. The
 `TraceHandlerInterceptor` adds a special request attribute to the given `HttpServletRequest`. If the
 the `TraceFilter` doesn't see this attribute set it will create a "fallback" span which is an additional
 span created on the server side so that the trace is presented properly in the UI. Seeing that most likely
 signifies that there is a missing instrumentation. In that case please file an issue in Spring Cloud Sleuth.

==== Async Servlet support

If your controller returns a `Callable` or a `WebAsyncTask` Spring Cloud Sleuth will continue the existing span instead of creating a new one.

==== WebFlux support

Via the `TraceWebFilter` all sampled incoming requests result in creation of a Span. That Span's name is `http:` + the path to which
 the request was sent. E.g. if the request was sent to `/foo/bar` then the name will be `http:/foo/bar`. You can configure which URIs you would
 like to skip via the `spring.sleuth.web.skipPattern` property. If you have `ManagementServerProperties` on classpath then
 its value of `contextPath` gets appended to the provided skip pattern.

=== HTTP client integration

==== Synchronous Rest Template

We're injecting a `RestTemplate` interceptor that ensures that all the tracing information is passed to the requests. Each time a
call is made a new Span is created. It gets closed upon receiving the response. In order to block the synchronous `RestTemplate` features
just set `spring.sleuth.web.client.enabled` to `false`.

IMPORTANT: You have to register `RestTemplate` as a bean so that the interceptors will get injected.
If you create a `RestTemplate` instance with a `new` keyword then the instrumentation WILL NOT work.

==== Asynchronous Rest Template

IMPORTANT: Starting with Sleuth `2.0.0` we no longer register
a bean of `AsyncRestTemplate` type. It's up to you to create such
a bean. Then we will instrument it.

To block the `AsyncRestTemplate` features set `spring.sleuth.web.async.client.enabled` to `false`.
To disable creation of the default `TraceAsyncClientHttpRequestFactoryWrapper` set `spring.sleuth.web.async.client.factory.enabled`
to `false`. If you don't want to create `AsyncRestClient` at all set `spring.sleuth.web.async.client.template.enabled` to `false`.

===== Multiple Asynchronous Rest Templates

Sometimes you need to use multiple implementations of Asynchronous Rest Template. In the following snippet you
can see an example of how to set up such a custom `AsyncRestTemplate`.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/web/client/MultipleAsyncRestTemplateTests.java[tags=custom_async_rest_template,indent=0]
----

==== WebClient

We inject a `ExchangeFilterFunction` implementation that creates a span and via on success and on
error callbacks takes care of closing client side spans.

IMPORTANT: You have to register `WebClient` as a bean so that the tracing instrumention gets applied.
If you create a `WebClient` instance with a `new` keyword then the instrumentation WILL NOT work.

==== Traverson

If you're using the http://docs.spring.io/spring-hateoas/docs/current/reference/html/#client.traverson[Traverson] library
it's enough for you to inject a `RestTemplate` as a bean into your Traverson object. Since `RestTemplate`
is already intercepted, you will get full support of tracing in your client. Below you can find a pseudo code
of how to do that:

[source,java]
----
@Autowired RestTemplate restTemplate;

Traverson traverson = new Traverson(URI.create("http://some/address"),
    MediaType.APPLICATION_JSON, MediaType.APPLICATION_JSON_UTF8).setRestOperations(restTemplate);
// use Traverson
----

=== Feign

By default Spring Cloud Sleuth provides integration with feign via the `TraceFeignClientAutoConfiguration`. You can disable it entirely
by setting `spring.sleuth.feign.enabled` to false. If you do so then no Feign related instrumentation will take place.

Part of Feign instrumentation is done via a `FeignBeanPostProcessor`. You can disable it by providing the `spring.sleuth.feign.processor.enabled` equal to `false`.
If you set it like this then Spring Cloud Sleuth will not instrument any of your custom Feign components. All the default instrumentation
however will be still there.

=== Asynchronous communication

==== @Async annotated methods

In Spring Cloud Sleuth we're instrumenting async related components so that the tracing information is passed between threads.
You can disable this behaviour by setting the value of `spring.sleuth.async.enabled` to `false`.

If you annotate your method with `@Async` then we'll automatically create a new Span with the following characteristics:

    - if the method is annotated with `@SpanName` then the value of the annotation will be the Span's name
    - if the method is *not* annotated with `@SpanName` the Span name will be the annotated method name
    - the Span will be tagged with that method's class name and the method name too

==== @Scheduled annotated methods

In Spring Cloud Sleuth we're instrumenting scheduled method execution so that the tracing information is passed between threads. You can disable this behaviour
by setting the value of `spring.sleuth.scheduled.enabled` to `false`.

If you annotate your method with `@Scheduled` then we'll automatically create a new Span with the following characteristics:

    - the Span name will be the annotated method name
    - the Span will be tagged with that method's class name and the method name too

If you want to skip Span creation for some `@Scheduled` annotated classes you can set the
`spring.sleuth.scheduled.skipPattern` with a regular expression that will match the fully qualified name of the
`@Scheduled` annotated class.

TIP: If you are using `spring-cloud-sleuth-stream` and `spring-cloud-netflix-hystrix-stream` together, Span will be created for each Hystrix metrics and sent to Zipkin. This may be annoying. You can prevent this by setting `spring.sleuth.scheduled.skipPattern=org.springframework.cloud.netflix.hystrix.stream.HystrixStreamTask`

==== Executor, ExecutorService and ScheduledExecutorService

We're providing `LazyTraceExecutor`, `TraceableExecutorService` and `TraceableScheduledExecutorService`. Those implementations
are creating Spans each time a new task is submitted, invoked or scheduled.

Here you can see an example of how to pass tracing information with `TraceableExecutorService` when working with `CompletableFuture`:

[source,java]
----

include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/async/TraceableExecutorServiceTests.java[tags=completablefuture,indent=0]
----

IMPORTANT: Sleuth doesn't work with `parallelStream()` out of the box. If you want
to have the tracing information propagated through the stream you have to use the
approach with `supplyAsync(...)` as presented above.

===== Customization of Executors

Sometimes you need to set up a custom instance of the `AsyncExecutor`. In the following snippet you
can see an example of how to set up such a custom `Executor`.

[source,java]
----
include::../../../../spring-cloud-sleuth-core/src/test/java/org/springframework/cloud/sleuth/instrument/web/client/MultipleAsyncRestTemplateTests.java[tags=custom_executor,indent=0]
----

=== Messaging

Spring Cloud Sleuth integrates with http://projects.spring.io/spring-integration/[Spring Integration]. It creates spans for publish and
subscribe events. To disable Spring Integration instrumentation, set `spring.sleuth.integration.enabled` to false.

You can provide the `spring.sleuth.integration.patterns` pattern to explicitly
provide the names of channels that you want to include for tracing. By default all channels
are included.

IMPORTANT: When using the `Executor` to build a Spring Integration `IntegrationFlow` remember to use the *untraced* version of the `Executor`.
Decorating Spring Integration Executor Channel with `TraceableExecutorService` will cause the spans to be improperly closed.

=== Zuul

We're registering Zuul filters to propagate the tracing information (the request header is enriched with tracing data).
To disable Zuul support set the `spring.sleuth.zuul.enabled` property to `false`.

== Running examples

You can find the running examples deployed in the https://run.pivotal.io/[Pivotal Web Services]. Check them out in the following links:

- http://docssleuth-zipkin-server.cfapps.io/[Zipkin for apps presented in the samples to the top]
- http://docsbrewing-zipkin-server.cfapps.io/[Zipkin for Brewery on PWS], its https://github.com/spring-cloud-samples/brewery[Github Code]
